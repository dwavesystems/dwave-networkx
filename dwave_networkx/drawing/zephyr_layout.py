# Copyright 2021 D-Wave Systems Inc.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

"""
Tools to visualize :term:`Zephyr` lattices and weighted :term:`graph` problems on them.
"""

import networkx as nx
from networkx import draw
import numpy as np

from dwave_networkx.drawing.qubit_layout import draw_qubit_graph, draw_embedding, draw_yield
from dwave_networkx.generators.zephyr import zephyr_coordinates, defect_free_zephyr
from dwave_networkx.topology import ZEPHYR

__all__ = ['zephyr_layout',
           'draw_zephyr',
           'draw_zephyr_embedding',
           'draw_zephyr_yield',
           ]

@ZEPHYR.layout.implementation
def zephyr_layout(G, scale=1., center=None, dim=2):
    """Positions the nodes of graph ``G`` in a Zephyr topology.

    Parameters
    ----------
    G : NetworkX graph
        :term:`Zephyr` :term:`graph` or a :term:`subgraph` of a Zephyr graph as produced by
        the :func:`dwave_networkx.zephyr_graph` function.

    scale : float (default 1.)
        Scale factor. If ``scale`` = 1, all positions fit within
        [0, 1] on the x-axis and [-1, 0] on the y-axis.

    center : None or array (default None)
        Coordinates of the top left corner.

    dim : int (default 2)
        Number of dimensions. If ``dim`` > 2, all extra dimensions are
        set to 0.

    Returns
    -------
    pos : dict
        Positions as a dictionary keyed by node.

    Examples
    --------
        This example gives the positions of a Zephyr lattice of size 2.

    >>> G = dnx.zephyr_graph(2)
    >>> pos = dnx.zephyr_layout(G)

    """

    if not isinstance(G, nx.Graph) or G.graph.get("family") != ZEPHYR:
        raise ValueError("G must be generated by dwave_networkx.zephyr_graph")

    xy_coords = zephyr_node_placer_2d(G, scale, center, dim)

    if G.graph.get('labels') == 'coordinate':
        pos = {v: xy_coords(*v) for v in G.nodes()}
    elif G.graph.get('data'):
        pos = {v: xy_coords(*dat['zephyr_index']) for v, dat in G.nodes(data=True)}
    else:
        m = G.graph.get('rows')
        t = G.graph.get('tile')
        coord = zephyr_coordinates(m, t)
        pos = {v: xy_coords(*coord.linear_to_zephyr(v)) for v in G.nodes()}
        
    if center is None:
        center = np.zeros(dim)
    else:
        center = np.asarray(center)

    pos_arr = np.array([(pos[v]-center)[:2] for v in G.nodes()])
    min_x, min_y = np.min(pos_arr, axis=0)
    max_x, max_y = np.max(pos_arr, axis=0)
    scale_x = max_x - min_x
    scale_y = max_y - min_y
    pos_arr = pos_arr - np.array([min_x , max_y]) # shift to make (0, 0) the top left corner
    pos_arr = pos_arr * np.array([1/scale_x, 1/scale_y]) # scale to make (1, -1) the bottom right corner
    paddims = dim - 2
    zeros = np.zeros((pos_arr.shape[0], paddims))
    pos_arr = np.hstack((pos_arr*np.array([scale, scale]), zeros)) + center 
    pos = {v: pos_arr[i] for i, v in enumerate(G.nodes())}
    
    return pos


def zephyr_node_placer_2d(G, scale=1., center=None, dim=2):
    """Generates a function to convert Zephyr indices to plottable coordinates.

    Parameters
    ----------
    G : NetworkX graph
        :term:`Zephyr` :term:`graph` or a :term:`subgraph` of a Zephyr graph as produced by
        the :func:`dwave_networkx.zephyr_graph` function.

    scale : float (default 1.)
        Scale factor. If ``scale`` = 1, all positions fit within
        [0, 1] on the x-axis and [-1, 0] on the y-axis.

    center : None or array (default None)
        Coordinates of the top left corner.

    dim : int (default 2)
        Number of dimensions. If ``dim`` > 2, all extra dimensions are
        set to 0.

    Returns
    -------
    xy_coords : Function
        Function that maps a Zephyr index ``(u, w, k, j, z)`` in a
        Zephyr lattice to plottable x- and y-coordinates.

    """

    m = G.graph.get('rows')
    tile_width = G.graph.get("tile")

    # want the enter plot to fill in [0, 1] when scale=1
    scale /= m * tile_width

    if center is None:
        center = np.zeros(dim)
    else:
        center = np.asarray(center)

    paddims = dim - 2
    if paddims < 0:
        raise ValueError("layout must have at least two dimensions")

    if len(center) != dim:
        raise ValueError("length of center coordinates must match dimension of layout")

    def _xy_coords(u, w, k, j, z):
        # orientation, major perpendicular offset, secondary perpendicular offset, minor perpendicular offset, parallel offset
        W = 2*tile_width*w + 2*k + .625*j + .125
        Z = (2*z+j+1)*2*tile_width - .5

        if u:
            xy = np.array([Z, -W])
        else:
            xy = np.array([W, -Z])

        return np.hstack((xy * scale, np.zeros(paddims))) + center
    return _xy_coords


@ZEPHYR.draw.implementation
def draw_zephyr(G, **kwargs):
    """Draws graph ``G`` in a Zephyr topology.

    Parameters
    ----------
    G : NetworkX graph
        :term:`Zephyr` :term:`graph` or a :term:`subgraph` of a Zephyr graph as produced by
        the :func:`dwave_networkx.zephyr_graph` function.

    linear_biases : dict (optional, default {})
        Linear biases as a dict of the form ``{node: bias, ...}``, where keys are
        nodes in ``G`` and biases are numeric.
        If specified, the linear biases are visualized on the plot.

    quadratic_biases : dict (optional, default {})
        Quadratic biases as a dict of the form ``{edge: bias, ...}``, where keys are
        edges in ``G`` and biases are numeric. Self-loop
        edges (i.e., :math:`i=j`) are treated as linear biases.
        If specified, the quadratic biases are visualized on the plot.

    kwargs : optional keywords
       Parameters in :func:`~networkx.drawing.nx_pylab.draw_networkx`, except for the ``pos`` parameter.
       If the ``linear_biases`` or ``quadratic_biases`` parameters are specified,
       the :func:`~networkx.drawing.nx_pylab.draw_networkx` ``node_color``
       or ``edge_color`` parameters are ignored.

    Examples
    --------
    This example plots a Zephyr graph with size parameter 2.

    >>> import networkx as nx
    >>> import dwave_networkx as dnx
    >>> import matplotlib.pyplot as plt   # doctest: +SKIP
    >>> G = dnx.zephyr_graph(2)
    >>> dnx.draw_zephyr(G)    # doctest: +SKIP
    >>> plt.show()    # doctest: +SKIP

    """

    draw_qubit_graph(G, zephyr_layout(G), **kwargs)


@ZEPHYR.draw_embedding.implementation
def draw_zephyr_embedding(G, *args, **kwargs):
    """Draws an embedding onto a Zephyr graph ``G``.

    Parameters
    ----------
    G : NetworkX graph
        :term:`Zephyr` :term:`graph` or a :term:`subgraph` of a Zephyr graph as produced by
        the :func:`dwave_networkx.zephyr_graph` function.

    emb : dict
        Minor-embedding as a dict of the form ``{node: chain, ...}``, where ``node`` is
        nodes in ``G`` and ``chain`` is iterables of qubit labels.

    embedded_graph : NetworkX graph (optional, default None)
        Graph that contains all keys of the ``emb`` parameter as nodes. If specified,
        the edges of ``G`` are considered interactions if and only if (1) they
        exist between two chains of the ``emb`` parameter and (2) the keys of the
        corresponding chains are connected by an edge in the given graph.
        If given, only the couplers between chains based on this graph are displayed.

    interaction_edges : list (optional, default None)
        Interactions as a list of edges. If specified,
        only these couplers are displayed.

    show_labels: boolean (optional, default False)
        If True, each chain in the ``emb`` parameter is labelled with its key.

    chain_color : dict (optional, default None)
        Colors as a dict of the form ``{node: rgba_color, ...}`` associated with
        each key in the ``emb`` parameter, where colors are length-4 tuples of floats
        between 0 and 1, inclusive. If None, each chain is assigned a
        different color.

    unused_color : tuple (optional, default (0.9,0.9,0.9,1.0))
        Color for graph ``G``'s nodes that are not part of chains and edges
        that are neither chain edges nor interactions. If None, these
        nodes and edges are not shown.

    overlapped_embedding: boolean (optional, default False)
        If True, chains in the ``emb`` parameter may overlap (contain the same vertices
        in ``G``), and these overlaps are displayed as concentric circles.

    kwargs : optional keywords
       Parameters in :func:`~networkx.drawing.nx_pylab.draw_networkx`, except for the ``pos`` parameter.
       If the ``linear_biases`` or ``quadratic_biases`` parameters are specified,
       the :func:`~networkx.drawing.nx_pylab.draw_networkx` ``node_color``
       or ``edge_color`` parameters are ignored.
    """
    draw_embedding(G, zephyr_layout(G), *args, **kwargs)

@ZEPHYR.draw_yield.implementation
def draw_zephyr_yield(G, **kwargs):
    """Draws graph ``G`` with highlighted faults, according to the Zephyr layout.

    Parameters
    ----------
    G : NetworkX graph
        :term:`Graph` to be parsed for faults.

    unused_color : tuple or color string (optional, default (0.9,0.9,0.9,1.0))
        Color to use for nodes and edges of ``G`` which are not faults.
        If None, these nodes and edges are not shown.

    fault_color : tuple or color string (optional, default (1.0,0.0,0.0,1.0))
        Color to represent nodes absent from the graph ``G``. Colors must be
        length-4 tuples of floats between 0 and 1, inclusive.

    fault_shape : string, optional (default='x')
        Shape of the fault nodes. The shapes are the same as those specified for
        `Matplotlib markers <https://matplotlib.org/stable/api/markers_api.html#module-matplotlib.markers>`_.

    fault_style : string, optional (default='dashed')
        Line style for fault edges. The line style can be any of the following values:
        ``'solid'``, ``'dashed'``, ``'dotted'``, ``'dashdot'``.

    kwargs : optional keywords
       Parameters in :func:`~networkx.drawing.nx_pylab.draw_networkx`, except for the ``pos`` parameter.
       If the ``linear_biases`` or ``quadratic_biases`` parameters are specified,
       the :func:`~networkx.drawing.nx_pylab.draw_networkx` ``node_color``
       or ``edge_color`` parameters are ignored.
    """
    perfect_graph = defect_free_zephyr(G)
    draw_yield(G, zephyr_layout(perfect_graph), perfect_graph, **kwargs)
